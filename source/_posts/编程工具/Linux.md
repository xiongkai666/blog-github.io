---
title: Linux面试八股文
tags: 
- C++
- Linux
categories: 操作系统
---
# LT（水平触发）和ET（边缘触发）的区别⭐
LT（Level Trigger，水平触发）和ET（Edge Trigger，边缘触发）是两种不同的事件触发模式，常见于I/O多路复用技术（如Linux下的`select`、`poll`、`epoll`）中，它们在事件触发机制、处理方式和适用场景等方面存在明显区别。

---
### 1. 事件触发机制
- **LT（水平触发）**
    - 只要文件描述符（FD）对应的缓冲区还有数据可读或者可写，就会一直触发相应的读或写事件。也就是说，只要输入缓冲区中有数据，读事件就会持续触发；只要输出缓冲区有空闲空间，写事件就会持续触发。
    - 例如，当有数据到达某个套接字的输入缓冲区时，LT模式会一直通知应用程序有数据可读，直到输入缓冲区中的数据被全部读取完。
 - **ET（边缘触发）**
    - 仅在文件描述符对应的缓冲区状态发生变化的瞬间触发事件。对于读事件，只有当新的数据到达，缓冲区状态从无数据变为有数据时才会触发；对于写事件，只有当输出缓冲区从满变为有空闲空间时才会触发。
    - 例如，当有新的数据到达套接字的输入缓冲区时，ET模式会触发一次读事件，如果应用程序没有将输入缓冲区中的数据全部读取完，后续即使缓冲区中还有数据，也不会再触发读事件，直到有新的数据再次到达。
---
### 2. 处理方式
- **LT（水平触发）**
    - 编程相对简单，应用程序可以在事件触发时进行部分数据的处理，不需要一次性将缓冲区中的数据处理完。因为只要缓冲区中还有数据，后续还会继续触发事件。
    - 例如，在处理读事件时，应用程序可以每次读取一部分数据，处理完后等待下一次事件触发再继续读取。
 - **ET（边缘触发）**
    - 编程复杂度较高，要求应用程序在事件触发时尽可能多地处理数据，通常需要一次性将缓冲区中的数据全部处理完。因为如果没有处理完，后续可能不会再收到该事件的触发通知。
    - 例如，在处理读事件时，应用程序需要使用循环不断地从输入缓冲区中读取数据，直到读取返回`EAGAIN`或`EWOULDBLOCK`错误，表示缓冲区中已经没有数据可读。
---
### 3. 性能特点
- **LT（水平触发）**
    - 由于会持续触发事件，可能会导致频繁的系统调用，增加系统开销。特别是在数据量较大或者处理速度较慢的情况下，会频繁触发事件，影响系统性能。
    - 但它的优点是可靠性高，不容易丢失数据，适合对数据处理实时性要求不高、数据量较小的场景。
 - **ET（边缘触发）**
    - 事件触发次数相对较少，减少了系统调用的开销，性能较高。因为只有在缓冲区状态发生变化时才会触发事件，避免了不必要的系统调用。
    - 然而，由于要求一次性处理完数据，对应用程序的处理能力和编程技巧要求较高，如果处理不当，可能会导致数据丢失。它适合对性能要求较高、数据处理能力较强的场景。
---
### 4. 适用场景
- **LT（水平触发）**
    - 适用于对数据处理实时性要求不高、数据量较小的场景，如简单的网络服务程序，对性能要求不是特别苛刻，更注重编程的简单性和数据处理的可靠性。
 - **ET（边缘触发）**
    - 适用于对性能要求较高、数据处理能力较强的场景，如高并发的网络服务器，需要高效地处理大量的并发连接和数据，能够充分发挥ET模式减少系统调用开销的优势。 
---
# `select`、`poll` 和 `epoll`比较⭐
select、poll 和 epoll 是 Linux 下实现 I/O 多路复用的三种机制，用于高效处理多个文件描述符的 I/O 事件，从而提高程序的并发处理能力。

---
### 1. 数据结构
- **select**
    - 使用 `fd_set` 数据结构来存储需要监听的文件描述符集合。`fd_set` 本质上是一个位数组，每一位对应一个文件描述符，通过 `FD_SET`、`FD_CLR`、`FD_ISSET` 和 `FD_ZERO` 等宏来操作。
    - 由于 `fd_set` 是位数组，其大小是固定的，通常由 `FD_SETSIZE` 宏定义，默认值为 1024，这限制了 `select` 能够监听的文件描述符数量。
- **poll**
    - 使用 `struct pollfd` 数组来存储需要监听的文件描述符及其关注的事件。`struct pollfd` 结构体包含文件描述符、关注的事件和返回的事件等信息。
    - 数组的大小可以根据需要动态分配，因此 `poll` 没有像 `select` 那样固定的文件描述符数量限制。
- **epoll**
    - 使用红黑树来管理需要监听的文件描述符，红黑树是一种自平衡的二叉搜索树，插入、删除和查找操作的时间复杂度为 $O(log n)$。
    - 同时使用一个链表来存储就绪的文件描述符，当有文件描述符就绪时，会将其添加到链表中，应用程序可以直接从链表中获取就绪的文件描述符，提高了查找效率。
---
### 2. 事件通知机制
- **select**
    - 采用轮询的方式来检查文件描述符的状态。当调用 `select` 函数时，内核会遍历所有被监听的文件描述符，检查它们是否有就绪的事件发生。
    - 每次调用 `select` 时，都需要将文件描述符集合从用户空间复制到内核空间，检查完成后再将结果从内核空间复制回用户空间，这种频繁的内存复制会带来一定的开销。
- **poll**
    - 同样采用轮询的方式来检查文件描述符的状态。`poll` 函数会遍历 `struct pollfd` 数组，检查每个文件描述符的状态。
    - 与 `select` 类似，`poll` 也需要在用户空间和内核空间之间复制数据，但由于 `poll` 使用结构体数组，而不是位数组，因此在处理大量文件描述符时，相对 `select` 更方便。
- **epoll**
    - 采用事件驱动的方式，使用回调机制。当有文件描述符就绪时，内核会通过回调函数将其添加到就绪链表中。
    - 应用程序只需要调用 `epoll_wait` 函数从就绪链表中获取就绪的文件描述符，避免了轮询操作，提高了效率。而且，`epoll` 只需要在注册文件描述符时将其从用户空间复制到内核空间，后续不需要频繁复制数据。
---
### 3. 时间复杂度
- **select**
    - 由于采用轮询的方式，每次调用 `select` 都需要遍历所有被监听的文件描述符，因此时间复杂度为 $O(n)$，其中 $n$ 是被监听的文件描述符数量。当文件描述符数量较多时，性能会明显下降。
- **poll**
    - 同样采用轮询的方式，每次调用 `poll` 也需要遍历所有的 `struct pollfd` 结构体，时间复杂度也是 $O(n)$。虽然 `poll` 没有文件描述符数量的限制，但在处理大量文件描述符时，性能仍然会受到影响。
- **epoll**
    - 由于使用红黑树管理文件描述符和回调机制，插入、删除和查找操作的时间复杂度为 $O(log n)$，而获取就绪文件描述符的时间复杂度为 $O(1)$。因此，`epoll` 在处理大量文件描述符时具有较好的性能。
---
### 4. 最大支持文件描述符数量
- **select**
    - 受限于 `fd_set` 的大小，通常最大支持的文件描述符数量为 `FD_SETSIZE`，默认值为 1024。虽然可以通过修改 `FD_SETSIZE` 并重新编译内核来增加这个限制，但这种方法比较麻烦，而且可能会带来其他问题。
- **poll**
    - 没有固定的文件描述符数量限制，只受限于系统资源（如内存）。可以根据需要动态分配 `struct pollfd` 数组的大小。
- **epoll**
    - 理论上没有文件描述符数量的限制，只受限于系统资源。在实际应用中，可以轻松处理大量的文件描述符。
---
### 5. 触发模式
- **select** 和 **poll**
    - 只支持电平触发（LT）模式。在电平触发模式下，只要文件描述符对应的缓冲区还有数据可读或者可写，就会一直触发相应的读或写事件。
- **epoll**
    - 支持电平触发（LT）和边缘触发（ET）两种模式。边缘触发模式仅在文件描述符对应的缓冲区状态发生变化的瞬间触发事件，相比电平触发模式，能减少事件触发的次数，提高性能，但编程复杂度较高。
---
### 6. 适用场景
- **select**
    - 适用于监听的文件描述符数量较少且不经常变化的场景，由于其实现简单，在一些简单的网络程序中仍然被广泛使用。
- **poll**
    - 适用于监听的文件描述符数量较多，但对性能要求不是特别高的场景。它解决了 `select` 文件描述符数量限制的问题，但在处理大量文件描述符时性能仍然不如 `epoll`。
- **epoll**
    - 适用于高并发的网络服务器，需要处理大量的并发连接和 I/O 事件。`epoll` 在处理大量文件描述符时具有明显的性能优势，是现代高性能网络编程的首选。

---
title: 常见手撕题
date: 2025-02-27 23:40:38
tags: 
- C++
- 多线程
categories: coding
---
## 使用C++实现一个读写锁
```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <mutex>
#include <condition_variable>
class ReadWriteLock {
private:
    std::mutex mtx;
    std::condition_variable read_cv, write_cv;
    int readers = 0;        // 当前读者数量
    int writers_waiting = 0; // 等待的写者数量
    bool writer_active = false; // 是否有写者正在工作

public:
    // 获取读锁
    void read_lock() {
        std::unique_lock<std::mutex> lock(mtx);
        // 等待条件：没有活跃的写者，且没有等待的写者（避免写者饥饿）
        read_cv.wait(lock, [this]() {
            return !writer_active && writers_waiting == 0;
        });
        readers++;
    }

    // 释放读锁
    void read_unlock() {
        std::unique_lock<std::mutex> lock(mtx);
        readers--;
        // 如果没有读者了，唤醒一个写者（如果有等待的写者）
        if (readers == 0) {
            write_cv.notify_one();
        }
    }

    // 获取写锁
    void write_lock() {
        std::unique_lock<std::mutex> lock(mtx);
        writers_waiting++; // 记录等待的写者
        // 等待条件：没有活跃的读者和写者
        write_cv.wait(lock, [this]() {
            return readers == 0 && !writer_active;
        });
        writers_waiting--;
        writer_active = true; // 标记写者活跃
    }

    // 释放写锁
    void write_unlock() {
        std::unique_lock<std::mutex> lock(mtx);
        writer_active = false;
        // 优先唤醒等待的写者，否则唤醒所有读者
        if (writers_waiting > 0) {
            write_cv.notify_one();
        } else {
            read_cv.notify_all();
        }
    }
};
//RAII 包装类（自动管理锁）
class ReadLockGuard {
private:
    ReadWriteLock& rw_lock;

public:
    explicit ReadLockGuard(ReadWriteLock& lock) : rw_lock(lock) {
        rw_lock.read_lock();
    }
    ~ReadLockGuard() {
        rw_lock.read_unlock();
    }
};

class WriteLockGuard {
private:
    ReadWriteLock& rw_lock;

public:
    explicit WriteLockGuard(ReadWriteLock& lock) : rw_lock(lock) {
        rw_lock.write_lock();
    }
    ~WriteLockGuard() {
        rw_lock.write_unlock();
    }
};
```
---